use std::{cmp::Reverse as Rev, marker::PhantomData};

use dary_heap::QuaternaryHeap;
use num_traits::{PrimInt, Unsigned};
use thin_vec::ThinVec;

enum BfsState {
    Init,
    Next,
    Done,
}

pub trait BfsStorage: PrimInt + Unsigned
where
    for<'a> Self: std::ops::AddAssign<&'a Self>,
{
}
impl<T> BfsStorage for T
where
    T: PrimInt + Unsigned,
    for<'a> Self: std::ops::AddAssign<&'a Self>,
{
}

pub trait BfsRank: Into<usize> + Unsigned + PrimInt {}
impl<T: Into<usize> + Unsigned + PrimInt> BfsRank for T {}

/// A breadth-first search node.
///
/// It is required that if n0 != n1, then n0 and n1's descendant sets are disjoint,
/// i.e. that the structure generated by N is a tree.
pub trait BfsNode
where
    Self: Eq + Sized + Clone,
{
    fn root() -> Self;
    fn children(&self) -> Vec<Self>;
}

// finite, fixed dimension N
// this case is heavily optimized to minimize heap usage as aggressively as possible, hence the
// following "unrolled" static policies

pub trait BfsPolicyZ<const N: usize, U>
where
    Self: Eq + Clone,
{
    fn root_xs() -> [U; N];
    fn allow(xs: &[U], i: usize) -> bool;
    fn need_shift_on_new_dim() -> bool {
        false
    }
}

// Free: always allowed, zeros root
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PolicyFree;
impl<const N: usize, U: BfsStorage> BfsPolicyZ<N, U> for PolicyFree {
    #[inline(always)]
    fn root_xs() -> [U; N] {
        [U::zero(); N]
    }
    #[inline(always)]
    fn allow(_: &[U], _: usize) -> bool {
        true
    }
}

// “NonDesc”: require xs[i] < xs[i-1] before increment, zeros root
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PolicyNonDesc;
impl<const N: usize, U: BfsStorage> BfsPolicyZ<N, U> for PolicyNonDesc {
    #[inline(always)]
    fn root_xs() -> [U; N] {
        [U::zero(); N]
    }
    #[inline(always)]
    fn allow(xs: &[U], i: usize) -> bool {
        i == 0 || xs[i] < xs[i - 1]
    }
}

// “Asc”: require xs[i]+1 < xs[i-1] after increment, descending root
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct PolicyAsc;
impl<const N: usize, U: BfsStorage> BfsPolicyZ<N, U> for PolicyAsc {
    #[inline(always)]
    fn root_xs() -> [U; N] {
        std::array::from_fn(|k| U::from(N - k - 1).unwrap())
    }
    #[inline(always)]
    fn allow(xs: &[U], i: usize) -> bool {
        i == 0 || (xs[i] + U::one()) < xs[i - 1]
    }

    #[inline(always)]
    fn need_shift_on_new_dim() -> bool {
        true
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BfsZn<const N: usize, U: BfsStorage, R: BfsRank, P: BfsPolicyZ<N, U>> {
    pub xs: [U; N],
    pub rank: R,
    phantom: PhantomData<P>,
}

impl<const N: usize, U: BfsStorage, R: BfsRank, P: BfsPolicyZ<N, U>> BfsNode for BfsZn<N, U, R, P> {
    fn root() -> Self {
        Self {
            xs: P::root_xs(),
            rank: R::from(0).unwrap(),
            phantom: PhantomData,
        }
    }

    fn children(&self) -> Vec<Self> {
        let mut out = Vec::with_capacity(N - self.rank.into());
        for ix in self.rank.into()..N {
            if !P::allow(&self.xs, ix) {
                continue;
            }
            let mut new = self.clone();
            new.xs[ix] += &U::one();
            unsafe {
                new.rank = R::from(ix).unwrap_unchecked();
            }
            out.push(new)
        }
        out
    }
}

// can reusde the Zn policy logic, will not call root_xs()
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BfsZω<U: BfsStorage, R: BfsRank, P: BfsPolicyZ<0, U>> {
    pub xs: ThinVec<U>,
    pub rank: R,
    phantom: PhantomData<P>,
}

impl<U: BfsStorage, R: BfsRank, P: BfsPolicyZ<0, U>> BfsNode for BfsZω<U, R, P> {
    fn root() -> Self {
        Self {
            xs: ThinVec::new(),
            rank: R::from(0).unwrap(),
            phantom: PhantomData,
        }
    }

    fn children(&self) -> Vec<Self> {
        let mut out = Vec::with_capacity(self.xs.len() + 1 - self.rank.into());
        // rank 0 means new dimension; otherise, rank is 1-based version of Zn
        for rx in self.rank.into()..=self.xs.len() {
            if rx == 0 {
                // new dimension
                let mut new = self.clone();
                if P::need_shift_on_new_dim() {
                    // e.g. for strictly ascending iteration, need to shift all existing values up by 1
                    for x in new.xs.iter_mut() {
                        *x += &U::one();
                    }
                }
                new.xs.push(U::zero());
                // new rank is zero already as needed
                out.push(new);
                continue;
            }
            if !P::allow(&self.xs, rx - 1) {
                continue;
            }
            let mut new = self.clone();
            new.xs[rx - 1] += &U::one();
            unsafe {
                new.rank = R::from(rx).unwrap_unchecked();
            }
            out.push(new)
        }
        out
    }
}

// to avoid needing BfsNode: Ord, we wrap a forgetful key type
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
struct BfsKey<N, T> {
    node: N,
    val: T,
}

impl<N: Eq, T: Ord> Ord for BfsKey<N, T> {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.val.cmp(&other.val)
    }
}

impl<N: Eq, T: Ord> PartialOrd for BfsKey<N, T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

/// Performs breadth-first search over some dynamic tree-like node type N.
pub struct Bfs<FVal, FGateXs, FGateVal, N, T>
where
    N: BfsNode,
    T: Ord,
    FVal: FnMut(&N) -> T,
    FGateXs: FnMut(&N) -> bool,
    FGateVal: FnMut(&T) -> bool,
{
    pub f_val: FVal,
    pub f_gate_xs: FGateXs,
    pub f_gate_val: FGateVal,
    heap: QuaternaryHeap<Rev<BfsKey<N, T>>>,
    state: BfsState,
}

impl<FVal, FGateXs, FGateVal, N, T> Bfs<FVal, FGateXs, FGateVal, N, T>
where
    N: BfsNode,
    T: Ord,
    FVal: FnMut(&N) -> T,
    FGateXs: FnMut(&N) -> bool,
    FGateVal: FnMut(&T) -> bool,
{
    pub fn new(f_val: FVal, f_gate_xs: FGateXs, f_gate_val: FGateVal) -> Self {
        Self {
            f_val,
            f_gate_xs,
            f_gate_val,
            heap: QuaternaryHeap::new(),
            state: BfsState::Init,
        }
    }
}

impl<FVal, FGateXs, FGateVal, N, T> Iterator for Bfs<FVal, FGateXs, FGateVal, N, T>
where
    N: BfsNode,
    T: Ord,
    FVal: FnMut(&N) -> T,
    FGateXs: FnMut(&N) -> bool,
    FGateVal: FnMut(&T) -> bool,
{
    type Item = (N, T);

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            match &mut self.state {
                BfsState::Init => {
                    let root = N::root();
                    if (self.f_gate_xs)(&root) {
                        let v = (self.f_val)(&root);
                        self.heap.push(Rev(BfsKey { node: root, val: v }));
                        self.state = BfsState::Next;
                        continue;
                    } else {
                        self.state = BfsState::Done;
                        continue;
                    }
                }
                BfsState::Next => match self.heap.pop() {
                    Some(Rev(BfsKey { node, val })) => {
                        for child in node.children() {
                            if !(self.f_gate_xs)(&child) {
                                continue;
                            }
                            let v = (self.f_val)(&child);
                            if !(self.f_gate_val)(&v) {
                                continue;
                            }
                            self.heap.push(Rev(BfsKey {
                                node: child,
                                val: v,
                            }));
                        }
                        return Some((node, val));
                    }
                    None => {
                        self.state = BfsState::Done;
                        continue;
                    }
                },
                BfsState::Done => {
                    return None;
                }
            }
        }
    }
}

/// Does an "infinite merge" of a family of iterables indexed by an integer dimension.
///
/// A new dimension is opened as needed, specifically when expanding the first element of the
/// previous dimension. this relies on assumption 2 below for correctness.
///
/// Assumptions:
///     let it(d) be the iterable of dimension d, and it(d)[n] be its nth yielded element
///     1. ∀d,n: it(d)[n] > it(d)[n - 1]
///     2. ∀d>1: it(d)[0] > it(d - 1)[0]
///     3. no iterator will ever yield None.
pub fn infinite_merge<T, F>(f: F) -> impl Iterator<Item = T>
where
    F: Fn(usize) -> Box<dyn Iterator<Item = T>>,
    T: Ord + std::fmt::Debug,
{
    let d0 = f(0);
    let mut dim_iters = vec![d0];
    let mut heap = QuaternaryHeap::new();
    let mut highest_dim = 0usize;
    heap.push(Rev((dim_iters[0].next(), 0)));

    std::iter::from_fn(move || {
        loop {
            if let Some(Rev((val, dim))) = heap.pop() {
                if val.is_none() {
                    // no push -- the dim is closed out forever
                    continue;
                } else {
                    // if we read from the highest dim, open the next one
                    if dim == highest_dim {
                        highest_dim += 1;
                        let mut new_iter = f(highest_dim);
                        heap.push(Rev((new_iter.next(), highest_dim)));
                        dim_iters.push(new_iter);
                    }
                    heap.push(Rev((dim_iters[dim].next(), dim)));
                }
                return val;
            } else {
                return None;
            }
        }
    })
}

#[cfg(test)]
mod tests {

    use crate::primes::lazy_primes;

    use super::*;

    #[test]
    fn test_5_smooth_numbers_leq_1000() {
        type Node = BfsZn<3, u32, u8, PolicyFree>;
        let bfs = Bfs::new(
            |node: &Node| 2u32.pow(node.xs[0]) * 3u32.pow(node.xs[1]) * 5u32.pow(node.xs[2]),
            |_| true,
            |v: &u32| *v <= 1000,
        );
        let results: Vec<u32> = bfs.map(|(_, v)| v).collect();
        let expect = &[
            1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50,
            54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162,
            180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 384,
            400, 405, 432, 450, 480, 486, 500, 512, 540, 576, 600, 625, 640, 648, 675, 720, 729,
            750, 768, 800, 810, 864, 900, 960, 972, 1000,
        ];

        assert_eq!(results, expect);
    }

    #[test]
    fn test_squarefree_leq_100() {
        use crate::primes::lazy_primes;

        let mut primes = lazy_primes::<u32>();
        type Node = BfsZω<u32, u8, PolicyAsc>;
        let bfs = Bfs::new(
            move |node: &Node| {
                node.xs
                    .iter()
                    .map(|x| primes.demand_cloned(*x as usize))
                    .product()
            },
            |_| true,
            |v| *v <= 100,
        );
        let expected = &[
            1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35,
            37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71,
            73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97,
        ];
        assert_eq!(bfs.map(|(_, v)| v).collect::<Vec<u32>>(), expected);
    }

    #[test]
    fn test_infinite_merge() {
        // should give us all prime powers in order
        let new_dim = |d| {
            let mut lazy_primes = lazy_primes::<u32>();
            Box::new((1..).map(move |exp| lazy_primes.demand(d).pow(exp)))
                as Box<dyn Iterator<Item = u32>>
        };
        let merged = infinite_merge(new_dim);
        let expected = &[
            2, 3, 4, 5, 7, 8, 9, 11, 13, 16, 17, 19, 23, 25, 27, 29, 31, 32, 37, 41, 43, 47, 49,
            53, 59, 61, 64, 67, 71, 73, 79, 81, 83, 89, 97,
        ];
        assert_eq!(merged.take(35).collect::<Vec<u32>>(), expected);
    }
}
